% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve_MWCS.R
\name{solve_MWCS}
\alias{solve_MWCS}
\title{Heuristic solution of Maximum-weight Connected Subgraph problem}
\usage{
solve_MWCS(ig, scores, min_cluster_size = 2)
}
\arguments{
\item{ig}{igraph}

\item{scores}{Named vector of scores for nodes in ig}

\item{min_cluster_size}{Minimum size of disconnected components of linker graph to consider when searching for maximum-weight subgraph. If NULL, only considers largest connected component of linker graph.}
}
\value{
a subnetwork as an igraph object
}
\description{
Given a graph and a named vector of node scores, \code{solve_MWCS()} heuristically finds a solution to the maximum-weight connected subgraph problem.
}
\details{
Details are taken from the \emph{dnet} package documentation for the \code{dnetfind()} function:
\enumerate{
\item transform the input graph into a new graph by collapsing connected positive nodes into a meta-node. As such, meta-nodes are isolated to each other but are linked via negative nodes (single-nodes). Clearly, meta-nodes have positive scores, and negative scores for the single-nodes.
\item append the weight attribute to the edges in the transformed graph. There are two types of edges: i) the single-single edge with two single-nodes as two ends, and ii) single-meta edge with a single-node as one end and a meta-node as the other end. The weight for a single-single edge is the absolute sum of the scores in its two-end single-nodes but normalised by their degrees. The weight for a single-meta edge is simply the absolute score in its single-node end normalised by the degree. As such, weights are all non-negative.
\item find minimum spanning tree (MST) in the weighted transformed graph. A spanning tree of the weighted graph is a subgraph that is tree and connects all the node together. The MST is a spanning tree with the sum of its edge weights minimised amongst all possible spanning trees.
\item find all shortest paths between any pair of meta-nodes in the MST. Within the weighted transformed graph in 2), a subgraph is induced containing nodes (only occuring in these shortest paths) and all edges between them.
\item within the induced subgraph, identify single-nodes that are direct neighbors of meta-nodes. For each of these single-nodes, also make sure it has the absolute scores no more than the sum of scores in its neighboring meta-nodes. These single-nodes meeting both criteria are called "linkers".
\item still within the induced subgraph from 5), find the linker graph(s) that contains only linkers and edges between them. This will most likely be disconnected, resulting in multiple components. Similarly to 3), find MST of the linker graph(s), called 'linker MST'. Notably, these linker MST(s) serves as the scaffold, which only contains linkers but has meta-nodes being direcly attached to.
\item In each linker MST plus its attached meta-nodes, find the optimal path that has the sum of scores of its nodes and attached meta-nodes maximized amongest all possible paths. Nodes along these optimal paths plus their attached meta-nodes are called 'subgraph nodes'.
\item For each set of 'subgraph nodes', extract a subgraph (called 'subgraph') from the input graph that only contains subgraph nodes and edges betwen them.
\item Starting with the highest scoring subgraph, and in descending order based on sum of scores for each 'subgraph', merge two subgraphs. If the resulting subgraph sum of scores is greater than previous score, keep this merged subgraph. Else, move to the next subgraph.
\item Take the largest connected component of this (possibly merged) subgraph. This subgraph is the maximum scoring subgraph containing the positive nodes as many as possible, but the negative nodes as few as possible.
}
}
\note{
Adapted from the \emph{dnet} package to be much faster, with solutions closer to optimality. Based on method from the \emph{BioNet} package.
}
\examples{
library(igraph)

graph <- sample_pa(n = 100, power = 1.2)
V(graph)$name <- 1:100
g_scores <- rnorm(100)
names(g_scores) <- 1:100

new_g <- solve_MWCS(ig = graph, scores = g_scores)

}
\seealso{
\code{\link[=module_identification]{module_identification()}}, \code{\link[=RWR]{RWR()}}
}
