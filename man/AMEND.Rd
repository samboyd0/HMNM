% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AMEND.R
\name{AMEND}
\alias{AMEND}
\title{Identify modules from a network}
\usage{
AMEND(...)
}
\value{
a named list with the following elements:
\itemize{
\item module: igraph of the final module (i.e., subnetwork)
\item score: final module score
\item subnetworks: a list of node names contained in intermediate subnetworks
\item stats: data.frame of network and algorithm statistics
\item time: run time
\item input_params: list of input parameters
}
}
\description{
Given a network (or several networks, to be connected) with node-wise data, \code{module_identification()} uses the \strong{AMEND} algorithm to identify a single module containing highly-connected nodes with large data values. \code{AMEND()} is an alias.
}
\note{
\code{module_identification()} uses \emph{node_specific_restart}=TRUE for \code{RWR()}, with \emph{node_connectivity_score} coming from \code{node_connectivity_score(..., inverse=TRUE, mode="core")}.
}
\section{Algorithm Overview}{


The AMEND algorithm iteratively performs Random Walk with Restart (RWR) to obtain node scores which are used to heuristically find a maximum-weight connected subgraph. This subgraph is input for the next iteration, and the process continues until the subgraph size is close to the user-specified size \strong{n} or there is no change in network between iterations. See the \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10324253/}{manuscript} for more details.
}

\section{Network Hierarchy}{


\strong{AMEND} is powered by a generalized RWR algorithm that can analyze multilayer networks where nodes are categorized by overlapping factors organized hierarchically. This hierarchy is supplied by the user as a directed edeglist and governs the construction of the transition matrix for RWR, with information being shared more readily between layers that lie closer in the hierarchy.

The hierarchy can have an arbitrary number of levels, where each level is associated with a factor (e.g., tissue, molecule, data type). Each leaf in the hierarchy (i.e., category with no child categories, bottom level) corresponds to a layer in the multilayer network, and the nodes in a layer are defined by the categories of its ancestors in the hierarchy. See \code{\link[=create_network_hierarchy]{create_network_hierarchy()}} for more details.
}

\section{Network Inputs}{


Users can supply layers as separate network-like objects (igraph, adjacency matrix, or edgelist) in a named list, where names correspond to categories in hierarchy. Similar inputs can be given for bipartite mappings between layers, where list names denote the layer names to which the mapping will be applied, with multiple layer names separated by "|". Networks can be (un)weighted and/or (un)directed. A single, connected network will be constructed from the \strong{network_layers} and \strong{bipartite_networks} inputs (see \code{\link[=create_integrated_network]{create_integrated_network()}}).
}

\section{Seed Value and Transition Matrix Calculation}{


Seed values for RWR are computed from \strong{data}, \strong{FUN}, and \strong{FUN_params}. Users can also supply node-wise values in \strong{brw_attr} for a biased random walk, where larger values will increase transition probabilities to nodes during RWR. The \strong{brw_attr} argument can also be a character vector of node names. Continuous values for biased random walk will be generated for each node as an inverse function of distance to the given nodes.

Transition matrices can be created through classic column-normalization (\strong{normalize} = "degree") or through a modified column-normalization (\strong{normalize} = "modified_degree") which penalizes transitions to nodes as a function of node degree (to combat degree bias). See \code{\link[=transition_matrix]{transition_matrix()}} for more details on the transition matrix construction process.

The \strong{degree_bias} argument can further mitigate degree bias by applying a degree bias adjustment method to specific layers in the network (see \code{\link[=bistochastic_scaling]{bistochastic_scaling()}}).
}

\section{Aggregating Layers}{


In multilayer networks, there is the option to aggregate sets of layers after \code{\link[=RWR]{RWR()}} but prior to \code{\link[=solve_MWCS]{solve_MWCS()}}. For a given set of layers, the first layer listed is designated as the 'primary' layer. All nodes and edges of the primary layer will be kept in the aggregated network. Then, moving sequentially through the remaining layers in the set, edges (along with their adjacent nodes) are added only if at least one of its adjacent nodes is not already in the aggregated layer. RWR scores of common nodes will be averaged. This can be useful if certain layers only differ by their edge type (e.g., physical vs. functional interactions between proteins) and the user wants the module to only contain edges of a certain type.
}

\section{Additional Parameters}{


\strong{crosstalk_params} and \strong{seed_weights} are additional sets of parameters that allow fine control over diffusion dynamics during \code{\link[=RWR]{RWR()}}.

\strong{crosstalk_params} are parameters that control the amount of information shared between layers. They represent the probability of the random walker to jump from the current layer to another through a bipartite edge during RWR.

\strong{seed_weights} represent the relative weight to give to seeds values of a certain layer or sets of layers. These should be supplied for all sets of categories in hierarchy that share a common parent (i.e., siblings).
}

\examples{
# Attach igraph library
library(igraph)

# Inspect the multilayer network objects included in the package
multilayer_network # List object with 5 igraphs
interlayer_links 
multilayer_hierarchy # matrix representing a directed edgelist

# Inspect data to be mapped to nodes in multilayer network
# Represents p-values generated from runif
lapply(multilayer_data_runif, head)

crosstalk_params <- c(protdat = 0.2, phosphdat = 0.4, meta = 0.6)

seed_weights <- list(c(protdat = 0.4, phosphdat = 0.6), 
                     c(prot = 0.7, meta = 0.3),
                     c(prot2 = 0.7, meta2 = 0.3))

# Identify an active module from multilayer network
mod <- module_identification(network_layers = multilayer_network,
                            bipartite_networks = interlayer_links,
                            network_hierarchy = multilayer_hierarchy,
                            n = 50,
                            data = multilayer_data_runif,
                            FUN = "p_value",
                            normalize = "degree",
                            crosstalk_params = crosstalk_params,
                            seed_weights = seed_weights)
# Use alias 'AMEND()'
if(FALSE) {
mod <- AMEND(network_layers = multilayer_network,
             bipartite_networks = interlayer_links,
             network_hierarchy = multilayer_hierarchy,
             n = 50,
             data = multilayer_data_runif,
             FUN = "p_value",
             normalize = "degree",
             crosstalk_params = crosstalk_params,
             seed_weights = seed_weights)
}


}
\seealso{
\code{\link[=create_integrated_network]{create_integrated_network()}}, \link{create_network_hierarchy}, \code{\link[=transition_matrix]{transition_matrix()}}, \code{\link[=RWR]{RWR()}}, \code{\link[=solve_MWCS]{solve_MWCS()}}
}
